---
title: "Clase 11"
author: "Jose Pablo Vazquez"
date: "22/2/2021"
output: html_document
---


Es un proceso estoc치stico, hemos visto que hay dos par치metros, la volatilidad (que matem치ticamente equivale a la ra칤z de la varianza) y el rendimiento promedio (valor esperado). Para calcularlos, debemos primero obtener el cambio en el precio.

Poner la ecuaci칩n de como calcular el rendimiento diario. Tenemos dos opciones, una con el cambio del precio y otra con los logaritmos. como el precio es diario, cualquiera es adecuada.


```{r, include=FALSE}
library(quantmod)
library(PerformanceAnalytics)
library(lubridate)
library(tibble)
library(moments) ## Es para hacer las pruebas de normalidad
```

## Rendimiento Diario y Anualizado

```{r, include=FALSE}
clave <- "CREAL.MX"
datos <- new.env()
loadSymbols(clave, from = "2016-01-01", to=today(), env=datos)
precio <-datos[[clave]][,6]
names(precio) <- clave
```



```{r}
rendimiento <- na.omit(diff(log(precio)))
```


La volatilidad y el rendimiento son variables que dependen del tiempo

- estamos usando todo el periodo de informaci칩n desde el 2016 hasta el d칤a de hoy
```{r}
RDP <- mean(rendimiento)
RAP <- mean(rendimiento)*252

VD <- as.numeric(sqrt(var(rendimiento)))
VA <- as.numeric(sqrt(var(rendimiento)*252))

Est <- tibble(Perodo="2016-Fecha", RendD = paste(round(RDP*100,5),"%"), VolD = paste(round(VD*100,5),"%"),  RendA = paste(round(RAP*100,5),"%"), VolA=paste(round(VA*100,5),"%"))
Est
```


-Podemos obetenr estos par치metros por periodos


```{r, include=FALSE}
Rdp_2016 <- mean(rendimiento[year(rendimiento)==2016])
Vdp_2016 <- as.numeric(sqrt(var(rendimiento[year(rendimiento)==2016])))

Rap_2016 <- mean(rendimiento[year(rendimiento)==2016])*252
Vap_2016 <- as.numeric(sqrt(var(rendimiento[year(rendimiento)==2016])*252))

Est_2016 <- tibble(Perodo="2016", RendD = paste(round(Rdp_2016*100,5),"%"), VolD = paste(round(Vdp_2016*100,5),"%"),  RendA = paste(round(Rap_2016*100,5),"%"), VolA=paste(round(Vap_2016*100,5),"%"))
Est_2016
```


```{r}
rbind(Est, Est_2016)
```


## Normalidad en el rendimiento, en el precio y en el logaritmo del precio

La teor칤a nos dice que el rendimiento tiene un comportamiento mas o menos normal. Debido a que tiene una deformaci칩n leptoc칰rtica

Se har치 una prueba formal de normalidad

Jarque Bera (Aqu칤 junto con mi equipo voy a investigar/recordad que es una prueba de normalidad y voy a poner su forma matem치tica)

Relaciona el sesgo y la curtosis


Ho: Existe normalidad en la variable
Ha: No normalidad en la variable

La regla es que si el estad칤stico es mayor a 9.2130, se rechaza Ho.

```{r}
JBP <- jarque.test(as.numeric(precio))
JBR <- jarque.test(as.numeric(rendimiento))
JBPL <- jarque.test(as.numeric(log(precio)))

JB_est <- tibble(Periodo="2016-fecha", JB_precio = JBP[["statistic"]], JB_rend=JBR[["statistic"]], JB_logPrecio=JBPL[["statistic"]])
JB_est
```
Se rechaza Ho, la variable no es normal.


Con la informacion de la table nos damos cuenta de que todos los estad칤sticos son mayores a 9.2130, por lo cual , en ning칰n caso se pasa la prueba formal de normalidad.

En el caso del rendimiento esto sucede por que su distribuci칩n presenta leptocurtosis


```{r}
kurtosis(rendimiento)
skewness(rendimiento)
```


La curtosis, el sesgo y la normalidad dependen del tiempo

# Prueba de rendimiento

Ho: Media = 0
Ha: Media diferente de cero

Si el estad칤stico calculado es mayor al 2.3295, rechazar Ho.

```{r}
prueba <- t.test(as.numeric(rendimiento)) #Incluye toda la info desde el 2016
abs(prueba[["statistic"]])
```

Como el valor del estad칤stico es de -1.696484, eso quiere decir que no es mayor al 2.3295, entonces no podemos rechazar Ho. En conclusi칩n la media del rendimiento diario, es estadisticamente igual a cero.

Al igual que el rendimiento, esta prueba depende del tiempo

Si consideramos por ejemplo, solo el a침o 2017

```{r}
prueba <- t.test(as.numeric(rendimiento[year(rendimiento)==2017])) #Incluye toda la info desde el 2016
abs(prueba[["statistic"]])
```

Igual que antes no podemos rechazar Ho. El rendimiento es estad칤sticamente diferente de 0, se podr칤a asumir que son insignificantes.


# Simulaciones

## Ecuaci칩n ds

Usar los par치metros 洧랞, 洧랥 (diarios) de la distribuci칩n del periodo 2020 y construir la ecuaci칩n 洧녬洧 =
洧멇롚洧녬洧노 + 洧멇롚뀛롐놿롐 que representa una estimaci칩n del comportamiento del precio. Usar esta ecuaci칩n
para construir una simulaci칩n usando valores aleatorios y proporcionar una estimaci칩n del precio
dentro de 10, 20 y 40 d칤as. Incluir un intervalo de confianza al 95% para las estimaciones.

Usando MU y SIGMA en t칠rminos diarios, tenemos:

```{r}
mu <- mean(rendimiento[year(rendimiento)==2020])
sigma <- as.numeric(sqrt(var(rendimiento[year(rendimiento)==2020])))
mu
sigma
```

$$dS = `r mu`Sdt + `r sigma`SdW$$


Para dias dt = 10. Para el valor inicial So, vamos a usar el 칰ltimo d칤a de informaci칩n disponible.

```{r}
d <- length(precio)
So <- as.numeric(precio[d])
n <- 10000
dt <- 10
simula <- tibble(epsilon=rnorm(n), dS=mu*dt*So+sigma*So*sqrt(dt)*epsilon)
PE <- So+mean(simula$dS)
PE
```
La suma de esos dos valores ser칤a el valor ESperado

Int칠rvalo de confianza al 95%

el intervalo de confianza se construye con MU+-SIGMA*Z

MU y SIGMA del cambio en el precio ds.

```{r}
Media_ds <-mean(simula$dS) 
DesS_ds <- sqrt(var(simula$dS))
Z <- qnorm(0.975)
P_Sup <- So+Media_ds+Z*DesS_ds
P_Inf <- So+Media_ds-Z*DesS_ds
P_Sup
P_Inf
```











